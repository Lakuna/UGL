var t={d:(e,r)=>{for(var i in r)t.o(r,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:r[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{y3:()=>n,OW:()=>s,Ht:()=>r,pW:()=>i});const r=t=>t*Math.PI/180,i=(t,e,r,s=0)=>s+(r(t)+(t<e?i(t+1,e,r,s):0));class s extends Array{set(...t){for(;this.length>0;)this.pop();for(const e of t)this.push(e);return this}cross(t){return this.set(...s.fromRule(this.length,(e=>{const r=t=>t<this.length?t:t-this.length;e=r(e+1);let i=r(e+1);return this[e]*t[i]-this[i]*t[e]})))}operate(t,e){return this.set(...s.fromRule(this.length,(r=>e(this[r],t[r]))))}normalize(){return this.set(...s.fromRule(this.length,(t=>this[t]/this.magnitude)))}get magnitude(){return Math.sqrt(i(0,this.length-1,(t=>this[t]**2)))}}s.fromRule=(t,e)=>{let r=[];for(let i=0;i<t;i++)r[i]=e(i);return new s(r)};class n extends Array{set(...t){for(;this.length>0;)this.pop();for(const e of t)this.push(e);return this}getPoint(t,e,r=this.dim){return this[e*r+t]}setPoint(t,e,r,i=this.dim){this[e*i+t]=r}multiply(t,e=this.dim){t=new n(...t);const r=this.length/e,s=t.length/e;return this.set(...n.fromRule(r,s,((r,s)=>i(0,e-1,(e=>this.getPoint(r,e)*t.getPoint(e,s))))))}translate(t,e,r){return this.multiply([1,0,0,0,0,1,0,0,0,0,1,0,t,e,r,1])}pitch(t){const e=r(t),i=Math.cos(e),s=Math.sin(e);return this.multiply([1,0,0,0,0,i,s,0,0,-s,i,0,0,0,0,1])}yaw(t){const e=r(t),i=Math.cos(e),s=Math.sin(e);return this.multiply([i,0,-s,0,0,1,0,0,s,0,i,0,0,0,0,1])}roll(t){const e=r(t),i=Math.cos(e),s=Math.sin(e);return this.multiply([i,s,0,0,-s,i,0,0,0,0,1,0,0,0,0,1])}rotate(t,e,r){return this.pitch(t).yaw(e).roll(r)}scale(t,e,r){return this.multiply([t,0,0,0,0,e,0,0,0,0,r,0,0,0,0,1])}invert(){const t=this.dim;if(t**2!=this.length)throw new Error("Cannot invert a non-square matrix.");const e=n.identity(t),r=new n(...this);for(let i=0;i<t;i++){let s=r.getPoint(i,i);if(0==s){for(let s=i+1;s<t;s++)if(0!=r.getPoint(s,i)){for(let n=0;n<t;n++)[r,e].forEach((t=>{let e=t.getPoint(i,n);t.setPoint(i,n,t.getPoint(s,n)),t.setPoint(s,n,e)}));break}if(s=r.getPoint(i,i),0==s)throw new Error("Matrix is not invertible.")}for(let n=0;n<t;n++)[r,e].forEach((t=>t.setPoint(i,n,t.getPoint(i,n)/s)));for(let s=0;s<t;s++){if(s==i)continue;let n=r.getPoint(s,i);for(let o=0;o<t;o++)[r,e].forEach((t=>t.setPoint(s,o,t.getPoint(s,o)-n*t.getPoint(i,o))))}}return this.set(...e)}transpose(t=this.dim){return this.set(...s.fromRule(this.length,(e=>this.getPoint(Math.floor(e/(this.length/t)),e%(this.length/t),t))))}orthographic(t,e,r,i,s,n){return this.multiply([2/(e-t),0,0,0,0,2/(r-i),0,0,0,0,2/(s-n),0,(t+e)/(t-e),(i+r)/(i-r),(s+n)/(s-n),1])}perspective(t,e,i,s){const n=Math.tan(.5*Math.PI-.5*r(t)),o=1/(i-s);return this.multiply([n/e,0,0,0,0,n,0,0,0,0,(i+s)*o,-1,0,0,i*s*o*2,0])}lookAt(t,e,r=[0,1,0]){const i=new s(...t).operate(e,((t,e)=>t-e)).normalize(),n=new s(...r).cross(i).normalize(),o=new s(...i).cross(n).normalize();return this.multiply([...n,0,...o,0,...i,0,...t,1])}get dim(){return Math.sqrt(this.length)}}n.fromRule=(t,e,r)=>{let i=[];for(let s=0;s<t;s++)for(let n=0;n<e;n++)i[n*t+s]=r(s,n);return new n(...i)},n.identity=(t=4)=>n.fromRule(t,t,((t,e)=>t==e?1:0));var o=e.y3,h=e.OW,l=e.Ht,a=e.pW;export{o as Matrix,h as Vector,l as degreesToRadians,a as sigma};