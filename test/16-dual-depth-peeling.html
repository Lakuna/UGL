<!doctype html>

<html lang="en-US">
	<head>
		<title>Dual Depth Peeling</title>

		<!-- Prevent the browser console from complaining. -->
		<meta charset="utf-8" />
		<link rel="icon" href="./assets/favicon.ico" />

		<!-- Spector.js. -->
		<script src="../node_modules/spectorjs/dist/spector.bundle.js"></script>

		<!-- Test script. -->
		<script type="module">
			import {
				Context,
				Program,
				Vbo,
				Ebo,
				Vao,
				Texture2d,
				TextureFormat,
				TextureFilter,
				WrapMode,
				TextureDataType,
				Framebuffer,
				BlendEquation,
				BlendFunction
			} from "../dist/index.js";

			// https://umath.lakuna.pw/
			function createMatrix4Like() {
				return new Float32Array(16);
			}

			// https://umath.lakuna.pw/
			function identity(out) {
				out[0] = 1;
				out[1] = 0;
				out[2] = 0;
				out[3] = 0;
				out[4] = 0;
				out[5] = 1;
				out[6] = 0;
				out[7] = 0;
				out[8] = 0;
				out[9] = 0;
				out[10] = 1;
				out[11] = 0;
				out[12] = 0;
				out[13] = 0;
				out[14] = 0;
				out[15] = 1;
				return out;
			}

			// https://umath.lakuna.pw/
			function rotateY(matrix, radians, out) {
				const s = Math.sin(radians);
				const c = Math.cos(radians);

				const a00 = matrix[0];
				const a01 = matrix[1];
				const a02 = matrix[2];
				const a03 = matrix[3];
				const a20 = matrix[8];
				const a21 = matrix[9];
				const a22 = matrix[10];
				const a23 = matrix[11];

				if (out != matrix) {
					out[4] = matrix[4];
					out[5] = matrix[5];
					out[6] = matrix[6];
					out[7] = matrix[7];
					out[12] = matrix[12];
					out[13] = matrix[13];
					out[14] = matrix[14];
					out[15] = matrix[15];
				}

				out[0] = a00 * c - a20 * s;
				out[1] = a01 * c - a21 * s;
				out[2] = a02 * c - a22 * s;
				out[3] = a03 * c - a23 * s;
				out[8] = a00 * s + a20 * c;
				out[9] = a01 * s + a21 * c;
				out[10] = a02 * s + a22 * c;
				out[11] = a03 * s + a23 * c;
				return out;
			}

			// https://umath.lakuna.pw/
			function perspective(fov, aspect, near, far, out) {
				const f = 1 / Math.tan(fov / 2);

				out[0] = f / aspect;
				out[1] = 0;
				out[2] = 0;
				out[3] = 0;
				out[4] = 0;
				out[5] = f;
				out[6] = 0;
				out[7] = 0;
				out[8] = 0;
				out[9] = 0;
				out[11] = -1;
				out[12] = 0;
				out[13] = 0;
				out[15] = 0;

				if (far != null && far != Infinity) {
					const nf = 1 / (near - far);
					out[10] = (far + near) * nf;
					out[14] = 2 * far * near * nf;
				} else {
					out[10] = -1;
					out[14] = -2 * near;
				}

				return out;
			}

			// https://umath.lakuna.pw/
			function createVector3Like() {
				return new Float32Array(3);
			}

			// https://umath.lakuna.pw/
			function fromValues(x, y, z, out) {
				out[0] = x;
				out[1] = y;
				out[2] = z;
				return out;
			}

			// https://umath.lakuna.pw/
			function createVector4Like() {
				return new Float32Array(4);
			}

			// https://umath.lakuna.pw/
			function fromValues4(x, y, z, w, out) {
				out[0] = x;
				out[1] = y;
				out[2] = z;
				out[3] = w;
				return out;
			}

			// https://umath.lakuna.pw/
			const epsilon = 0.000001;

			// https://umath.lakuna.pw/
			function lookAt(eye, center, up, out) {
				const eyex = eye[0];
				const eyey = eye[1];
				const eyez = eye[2];

				const upx = up[0];
				const upy = up[1];
				const upz = up[2];

				const centerx = center[0];
				const centery = center[1];
				const centerz = center[2];

				if (
					Math.abs(eyex - centerx) < epsilon &&
					Math.abs(eyey - centery) < epsilon &&
					Math.abs(eyez - centerz) < epsilon
				) {
					return identity(out);
				}

				let z0 = eyex - centerx;
				let z1 = eyey - centery;
				let z2 = eyez - centerz;
				let len = 1 / Math.hypot(z0, z1, z2);
				z0 *= len;
				z1 *= len;
				z2 *= len;

				let x0 = upy * z2 - upz * z1;
				let x1 = upz * z0 - upx * z2;
				let x2 = upx * z1 - upy * z0;
				len = Math.hypot(x0, x1, x2);
				if (len > 0) {
					len = 1 / len;
					x0 *= len;
					x1 *= len;
					x2 *= len;
				} else {
					x0 = 0;
					x1 = 0;
					x2 = 0;
				}

				let y0 = z1 * x2 - z2 * x1;
				let y1 = z2 * x0 - z0 * x2;
				let y2 = z0 * x1 - z1 * x0;
				len = Math.hypot(y0, y1, y2);
				if (len > 0) {
					len = 1 / len;
					y0 *= len;
					y1 *= len;
					y2 *= len;
				} else {
					y0 = 0;
					y1 = 0;
					y2 = 0;
				}

				out[0] = x0;
				out[1] = y0;
				out[2] = z0;
				out[3] = 0;
				out[4] = x1;
				out[5] = y1;
				out[6] = z1;
				out[7] = 0;
				out[8] = x2;
				out[9] = y2;
				out[10] = z2;
				out[11] = 0;
				out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
				out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
				out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
				out[15] = 1;
				return out;
			}

			// https://umath.lakuna.pw/
			function multiply(a, b, out) {
				const a00 = a[0];
				const a01 = a[1];
				const a02 = a[2];
				const a03 = a[3];
				const a10 = a[4];
				const a11 = a[5];
				const a12 = a[6];
				const a13 = a[7];
				const a20 = a[8];
				const a21 = a[9];
				const a22 = a[10];
				const a23 = a[11];
				const a30 = a[12];
				const a31 = a[13];
				const a32 = a[14];
				const a33 = a[15];

				let b0 = b[0];
				let b1 = b[1];
				let b2 = b[2];
				let b3 = b[3];
				out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
				b0 = b[4];
				b1 = b[5];
				b2 = b[6];
				b3 = b[7];
				out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
				b0 = b[8];
				b1 = b[9];
				b2 = b[10];
				b3 = b[11];
				out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
				b0 = b[12];
				b1 = b[13];
				b2 = b[14];
				b3 = b[15];
				out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
				return out;
			}

			const depthPeelVss = `\
#version 300 es

in vec4 a_position;

uniform mat4 u_worldMat;
uniform mat4 u_viewProjMat;

void main() {
	gl_Position = u_viewProjMat * u_worldMat * a_position;
}
`;

			const depthPeelFss = `\
#version 300 es

precision mediump float;

uniform sampler2D u_depthTex;
uniform sampler2D u_frontColorTex;
uniform vec4 u_color;

layout(location = 0) out vec2 outDepth;
layout(location = 1) out vec4 outFrontColor;
layout(location = 2) out vec4 outBackColor;

void main() {
	float fragDepth = gl_FragCoord.z;
	ivec2 fragCoord = ivec2(gl_FragCoord.xy);
	vec2 lastDepth = texelFetch(u_depthTex, fragCoord, 0).rg;
	vec4 lastFrontColor = texelFetch(u_frontColorTex, fragCoord, 0);

	outDepth.rg = vec2(-1.000001);
	outFrontColor = lastFrontColor;
	outBackColor = vec4(0.0);

	float nearestDepth = -lastDepth.x;
	float furthestDepth = lastDepth.y;
	float alphaMultiplier = 1.0 - lastFrontColor.a;

	if (fragDepth < nearestDepth || fragDepth > furthestDepth) {
		return;
	}

	if (fragDepth > nearestDepth && fragDepth < furthestDepth) {
		outDepth.rg = vec2(-fragDepth, fragDepth);
		return;
	}

	if (fragDepth == nearestDepth) {
		outFrontColor.rgb += u_color.rgb * u_color.a * alphaMultiplier;
		outFrontColor.a = 1.0 - alphaMultiplier * (1.0 - u_color.a);
		return;
	}

	outBackColor += u_color;
}
`;

			const quadVss = `\
#version 300 es

in vec4 a_position;

void main() {
	gl_Position = a_position;
}
`;

			const blendBackFss = `\
#version 300 es

precision mediump float;

uniform sampler2D u_backColorTex;

out vec4 outColor;

void main() {
	outColor = texelFetch(u_backColorTex, ivec2(gl_FragCoord.xy), 0);
	if (outColor.a == 0.0) {
		discard;
	}
}
`;

			const finalFss = `\
#version 300 es

precision mediump float;

uniform sampler2D u_frontColorTex;
uniform sampler2D u_backColorTex;

out vec4 fragColor;

void main() {
	ivec2 fragCoord = ivec2(gl_FragCoord.xy);
	vec4 frontColor = texelFetch(u_frontColorTex, fragCoord, 0);
	vec4 backColor = texelFetch(u_backColorTex, fragCoord, 0);
	float alphaMultiplier = 1.0 - frontColor.a;

	fragColor = vec4(
		frontColor.rgb + alphaMultiplier * backColor.rgb,
		frontColor.a + backColor.a
	);
}
`;

			// XY plane/quad.
			const planePositionData = new Float32Array([-1, 1, -1, -1, 1, -1, 1, 1]);
			const planeIndexData = new Uint8Array([0, 1, 2, 0, 2, 3]);

			// Vanilla WebGL2 implementation.
			function raw(canvas) {
				const gl = canvas.getContext("webgl2");

				// Enable extensions.
				gl.getExtension("EXT_color_buffer_float");
				gl.getExtension("EXT_float_blend");

				// Depth peeling vertex shader.
				const depthPeelVs = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(depthPeelVs, depthPeelVss);
				gl.compileShader(depthPeelVs);
				if (!gl.getShaderParameter(depthPeelVs, gl.COMPILE_STATUS)) {
					throw new Error(gl.getShaderInfoLog(depthPeelVs));
				}

				// Depth peeling fragment shader.
				const depthPeelFs = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(depthPeelFs, depthPeelFss);
				gl.compileShader(depthPeelFs);
				if (!gl.getShaderParameter(depthPeelFs, gl.COMPILE_STATUS)) {
					throw new Error(gl.getShaderInfoLog(depthPeelFs));
				}

				// Quad vertex shader.
				const quadVs = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(quadVs, quadVss);
				gl.compileShader(quadVs);
				if (!gl.getShaderParameter(quadVs, gl.COMPILE_STATUS)) {
					throw new Error(gl.getShaderInfoLog(quadVs));
				}

				// Final fragment shader.
				const finalFs = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(finalFs, finalFss);
				gl.compileShader(finalFs);
				if (!gl.getShaderParameter(finalFs, gl.COMPILE_STATUS)) {
					throw new Error(gl.getShaderInfoLog(finalFs));
				}

				// Blend back fragment shader.
				const blendBackFs = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(blendBackFs, blendBackFss);
				gl.compileShader(blendBackFs);
				if (!gl.getShaderParameter(blendBackFs, gl.COMPILE_STATUS)) {
					throw new Error(gl.getShaderInfoLog(blendBackFs));
				}

				// Depth peeling shader program.
				const depthPeelProgram = gl.createProgram();
				gl.attachShader(depthPeelProgram, depthPeelVs);
				gl.attachShader(depthPeelProgram, depthPeelFs);
				gl.linkProgram(depthPeelProgram);
				if (!gl.getProgramParameter(depthPeelProgram, gl.LINK_STATUS)) {
					throw new Error(gl.getProgramInfoLog(depthPeelProgram));
				}

				// Final shader program.
				const finalProgram = gl.createProgram();
				gl.attachShader(finalProgram, quadVs);
				gl.attachShader(finalProgram, finalFs);
				gl.linkProgram(finalProgram);
				if (!gl.getProgramParameter(finalProgram, gl.LINK_STATUS)) {
					throw new Error(gl.getProgramInfoLog(finalProgram));
				}

				// Blend back shader program.
				const blendBackProgram = gl.createProgram();
				gl.attachShader(blendBackProgram, quadVs);
				gl.attachShader(blendBackProgram, blendBackFs);
				gl.linkProgram(blendBackProgram);
				if (!gl.getProgramParameter(blendBackProgram, gl.LINK_STATUS)) {
					throw new Error(gl.getProgramInfoLog(blendBackProgram));
				}

				// Delete shaders.
				gl.deleteShader(depthPeelVs);
				gl.deleteShader(depthPeelFs);
				gl.deleteShader(quadVs);
				gl.deleteShader(finalFs);
				gl.deleteShader(blendBackFs);

				// Get variable locations.
				const depthPeelWorldMatLoc = gl.getUniformLocation(
					depthPeelProgram,
					"u_worldMat"
				);
				const depthPeelViewProjMatLoc = gl.getUniformLocation(
					depthPeelProgram,
					"u_viewProjMat"
				);
				const depthPeelDepthTexLoc = gl.getUniformLocation(
					depthPeelProgram,
					"u_depthTex"
				);
				const depthPeelFrontColorTexLoc = gl.getUniformLocation(
					depthPeelProgram,
					"u_frontColorTex"
				);
				const depthPeelColorLoc = gl.getUniformLocation(
					depthPeelProgram,
					"u_color"
				);
				const depthPeelPosLoc = gl.getAttribLocation(
					depthPeelProgram,
					"a_position"
				);
				const finalFrontColorTexLoc = gl.getUniformLocation(
					finalProgram,
					"u_frontColorTex"
				);
				const finalBackColorTexLoc = gl.getUniformLocation(
					finalProgram,
					"u_backColorTex"
				);
				const finalPosLoc = gl.getAttribLocation(finalProgram, "a_position");
				const blendBackBackColorTexLoc = gl.getUniformLocation(
					blendBackProgram,
					"u_backColorTex"
				);
				const blendBackPosLoc = gl.getAttribLocation(
					blendBackProgram,
					"a_position"
				);

				// Create buffers.
				const planePositionBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, planePositionBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, planePositionData, gl.STATIC_DRAW);

				const planeIndexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeIndexBuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, planeIndexData, gl.STATIC_DRAW);

				// Create VAOs.
				const depthPeelPlaneVao = gl.createVertexArray();
				gl.bindVertexArray(depthPeelPlaneVao);
				gl.enableVertexAttribArray(depthPeelPosLoc);
				gl.bindBuffer(gl.ARRAY_BUFFER, planePositionBuffer);
				gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeIndexBuffer);

				const finalPlaneVao = gl.createVertexArray();
				gl.bindVertexArray(finalPlaneVao);
				gl.enableVertexAttribArray(finalPosLoc);
				gl.bindBuffer(gl.ARRAY_BUFFER, planePositionBuffer);
				gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeIndexBuffer);

				const blendBackPlaneVao = gl.createVertexArray();
				gl.bindVertexArray(blendBackPlaneVao);
				gl.enableVertexAttribArray(blendBackPosLoc);
				gl.bindBuffer(gl.ARRAY_BUFFER, planePositionBuffer);
				gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeIndexBuffer);

				// Texture initialization.
				const depthTarget0 = gl.createTexture();
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, depthTarget0);
				gl.texImage2D(
					gl.TEXTURE_2D,
					0,
					gl.RG32F,
					gl.drawingBufferWidth,
					gl.drawingBufferHeight,
					0,
					gl.RG,
					gl.FLOAT,
					null
				);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

				const frontColorTarget0 = gl.createTexture();
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, frontColorTarget0);
				gl.texImage2D(
					gl.TEXTURE_2D,
					0,
					gl.RGBA16F,
					gl.drawingBufferWidth,
					gl.drawingBufferHeight,
					0,
					gl.RGBA,
					gl.HALF_FLOAT,
					null
				);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

				const backColorTarget0 = gl.createTexture();
				gl.activeTexture(gl.TEXTURE2);
				gl.bindTexture(gl.TEXTURE_2D, backColorTarget0);
				gl.texImage2D(
					gl.TEXTURE_2D,
					0,
					gl.RGBA16F,
					gl.drawingBufferWidth,
					gl.drawingBufferHeight,
					0,
					gl.RGBA,
					gl.HALF_FLOAT,
					null
				);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

				const depthTarget1 = gl.createTexture();
				gl.activeTexture(gl.TEXTURE3);
				gl.bindTexture(gl.TEXTURE_2D, depthTarget1);
				gl.texImage2D(
					gl.TEXTURE_2D,
					0,
					gl.RG32F,
					gl.drawingBufferWidth,
					gl.drawingBufferHeight,
					0,
					gl.RG,
					gl.FLOAT,
					null
				);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

				const frontColorTarget1 = gl.createTexture();
				gl.activeTexture(gl.TEXTURE4);
				gl.bindTexture(gl.TEXTURE_2D, frontColorTarget1);
				gl.texImage2D(
					gl.TEXTURE_2D,
					0,
					gl.RGBA16F,
					gl.drawingBufferWidth,
					gl.drawingBufferHeight,
					0,
					gl.RGBA,
					gl.HALF_FLOAT,
					null
				);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

				const backColorTarget1 = gl.createTexture();
				gl.activeTexture(gl.TEXTURE5);
				gl.bindTexture(gl.TEXTURE_2D, backColorTarget1);
				gl.texImage2D(
					gl.TEXTURE_2D,
					0,
					gl.RGBA16F,
					gl.drawingBufferWidth,
					gl.drawingBufferHeight,
					0,
					gl.RGBA,
					gl.HALF_FLOAT,
					null
				);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

				const blendBackTarget = gl.createTexture();
				gl.activeTexture(gl.TEXTURE6);
				gl.bindTexture(gl.TEXTURE_2D, blendBackTarget);
				gl.texImage2D(
					gl.TEXTURE_2D,
					0,
					gl.RGBA16F,
					gl.drawingBufferWidth,
					gl.drawingBufferHeight,
					0,
					gl.RGBA,
					gl.HALF_FLOAT,
					null
				);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

				// Framebuffer initialization.
				const depthPeelFbo0 = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, depthPeelFbo0);
				gl.framebufferTexture2D(
					gl.FRAMEBUFFER,
					gl.COLOR_ATTACHMENT0,
					gl.TEXTURE_2D,
					depthTarget0,
					0
				);
				gl.framebufferTexture2D(
					gl.FRAMEBUFFER,
					gl.COLOR_ATTACHMENT1,
					gl.TEXTURE_2D,
					frontColorTarget0,
					0
				);
				gl.framebufferTexture2D(
					gl.FRAMEBUFFER,
					gl.COLOR_ATTACHMENT2,
					gl.TEXTURE_2D,
					backColorTarget0,
					0
				);

				const colorFbo0 = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, colorFbo0);
				gl.framebufferTexture2D(
					gl.FRAMEBUFFER,
					gl.COLOR_ATTACHMENT0,
					gl.TEXTURE_2D,
					frontColorTarget0,
					0
				);
				gl.framebufferTexture2D(
					gl.FRAMEBUFFER,
					gl.COLOR_ATTACHMENT1,
					gl.TEXTURE_2D,
					backColorTarget0,
					0
				);

				const depthPeelFbo1 = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, depthPeelFbo1);
				gl.framebufferTexture2D(
					gl.FRAMEBUFFER,
					gl.COLOR_ATTACHMENT0,
					gl.TEXTURE_2D,
					depthTarget1,
					0
				);
				gl.framebufferTexture2D(
					gl.FRAMEBUFFER,
					gl.COLOR_ATTACHMENT1,
					gl.TEXTURE_2D,
					frontColorTarget1,
					0
				);
				gl.framebufferTexture2D(
					gl.FRAMEBUFFER,
					gl.COLOR_ATTACHMENT2,
					gl.TEXTURE_2D,
					backColorTarget1,
					0
				);

				const colorFbo1 = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, colorFbo1);
				gl.framebufferTexture2D(
					gl.FRAMEBUFFER,
					gl.COLOR_ATTACHMENT0,
					gl.TEXTURE_2D,
					frontColorTarget1,
					0
				);
				gl.framebufferTexture2D(
					gl.FRAMEBUFFER,
					gl.COLOR_ATTACHMENT1,
					gl.TEXTURE_2D,
					backColorTarget1,
					0
				);

				const blendBackFbo = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, blendBackFbo);
				gl.framebufferTexture2D(
					gl.FRAMEBUFFER,
					gl.COLOR_ATTACHMENT0,
					gl.TEXTURE_2D,
					blendBackTarget,
					0
				);

				// Transformation initialization.
				const redMat = identity(createMatrix4Like());
				rotateY(redMat, Math.PI / 4, redMat);
				const greenMat = identity(createMatrix4Like());
				rotateY(greenMat, -Math.PI / 4, greenMat);
				const red = fromValues4(1, 0, 0, 0.5, createVector4Like());
				const green = fromValues4(0, 1, 0, 0.5, createVector4Like());
				const projMat = createMatrix4Like();
				const viewMat = createMatrix4Like();
				const eyePos = fromValues(0, 2, 2, createVector3Like());
				lookAt(eyePos, [0, 0, 0], [0, 1, 0], viewMat);
				const viewProjMat = createMatrix4Like();

				return function () {
					// Resize the drawing buffer.
					if (
						canvas.width !== canvas.clientWidth ||
						canvas.height !== canvas.clientHeight
					) {
						canvas.width = canvas.clientWidth;
						canvas.height = canvas.clientHeight;
						gl.viewport(0, 0, canvas.width, canvas.height);

						gl.activeTexture(gl.TEXTURE0);
						gl.bindTexture(gl.TEXTURE_2D, depthTarget0);
						gl.texImage2D(
							gl.TEXTURE_2D,
							0,
							gl.RG32F,
							gl.drawingBufferWidth,
							gl.drawingBufferHeight,
							0,
							gl.RG,
							gl.FLOAT,
							null
						);

						gl.activeTexture(gl.TEXTURE1);
						gl.bindTexture(gl.TEXTURE_2D, frontColorTarget0);
						gl.texImage2D(
							gl.TEXTURE_2D,
							0,
							gl.RGBA16F,
							gl.drawingBufferWidth,
							gl.drawingBufferHeight,
							0,
							gl.RGBA,
							gl.HALF_FLOAT,
							null
						);

						gl.activeTexture(gl.TEXTURE2);
						gl.bindTexture(gl.TEXTURE_2D, backColorTarget0);
						gl.texImage2D(
							gl.TEXTURE_2D,
							0,
							gl.RGBA16F,
							gl.drawingBufferWidth,
							gl.drawingBufferHeight,
							0,
							gl.RGBA,
							gl.HALF_FLOAT,
							null
						);

						gl.activeTexture(gl.TEXTURE3);
						gl.bindTexture(gl.TEXTURE_2D, depthTarget1);
						gl.texImage2D(
							gl.TEXTURE_2D,
							0,
							gl.RG32F,
							gl.drawingBufferWidth,
							gl.drawingBufferHeight,
							0,
							gl.RG,
							gl.FLOAT,
							null
						);

						gl.activeTexture(gl.TEXTURE4);
						gl.bindTexture(gl.TEXTURE_2D, frontColorTarget1);
						gl.texImage2D(
							gl.TEXTURE_2D,
							0,
							gl.RGBA16F,
							gl.drawingBufferWidth,
							gl.drawingBufferHeight,
							0,
							gl.RGBA,
							gl.HALF_FLOAT,
							null
						);

						gl.activeTexture(gl.TEXTURE5);
						gl.bindTexture(gl.TEXTURE_2D, backColorTarget1);
						gl.texImage2D(
							gl.TEXTURE_2D,
							0,
							gl.RGBA16F,
							gl.drawingBufferWidth,
							gl.drawingBufferHeight,
							0,
							gl.RGBA,
							gl.HALF_FLOAT,
							null
						);

						gl.activeTexture(gl.TEXTURE6);
						gl.bindTexture(gl.TEXTURE_2D, blendBackTarget);
						gl.texImage2D(
							gl.TEXTURE_2D,
							0,
							gl.RGBA16F,
							gl.drawingBufferWidth,
							gl.drawingBufferHeight,
							0,
							gl.RGBA,
							gl.HALF_FLOAT,
							null
						);
					}

					// Transformation update.
					perspective(
						Math.PI / 2,
						canvas.width / (canvas.height || 1),
						1,
						5,
						projMat
					);
					multiply(projMat, viewMat, viewProjMat);

					// Initialize the min-max depth buffer.

					// Set global state.
					gl.enable(gl.BLEND);
					gl.blendEquation(gl.MAX);
					gl.depthMask(false);
					gl.disable(gl.CULL_FACE);
					gl.clearColor(0, 0, 0, 0);

					// Bind the framebuffer.
					gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, blendBackFbo);

					// Clear the canvas.
					gl.clear(gl.COLOR_BUFFER_BIT);

					// Bind the framebuffer.
					gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, colorFbo0);
					gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);

					// Clear the canvas.
					gl.clear(gl.COLOR_BUFFER_BIT);

					// Bind the framebuffer.
					gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, colorFbo1);

					// Clear the canvas.
					gl.clear(gl.COLOR_BUFFER_BIT);

					// Set global state.
					gl.clearColor(0, 1, 0, 0);

					// Bind the framebuffer.
					gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, depthPeelFbo1);

					// Clear the canvas.
					gl.clear(gl.COLOR_BUFFER_BIT);

					// Set global state.
					gl.clearColor(-(1 + epsilon), -(1 + epsilon), 0, 0);

					// Bind the framebuffer.
					gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, depthPeelFbo0);
					gl.drawBuffers([gl.COLOR_ATTACHMENT0]);

					// Clear the canvas.
					gl.clear(gl.COLOR_BUFFER_BIT);

					// Use the program.
					gl.useProgram(depthPeelProgram);

					// Bind the VAO.
					gl.bindVertexArray(depthPeelPlaneVao);

					// Set uniform values.
					gl.uniform1i(depthPeelDepthTexLoc, 3);
					gl.uniform1i(depthPeelFrontColorTexLoc, 4);
					gl.uniformMatrix4fv(depthPeelViewProjMatLoc, false, viewProjMat);
					gl.uniform4fv(depthPeelColorLoc, red);
					gl.uniformMatrix4fv(depthPeelWorldMatLoc, false, redMat);

					// Render.
					gl.drawElements(
						gl.TRIANGLES,
						planeIndexData.length,
						gl.UNSIGNED_BYTE,
						0
					);

					// Set uniform values.
					gl.uniform4fv(depthPeelColorLoc, green);
					gl.uniformMatrix4fv(depthPeelWorldMatLoc, false, greenMat);

					// Render.
					gl.drawElements(
						gl.TRIANGLES,
						planeIndexData.length,
						gl.UNSIGNED_BYTE,
						0
					);

					// Dual depth peeling ping-pong.
					const passCount = 1;
					for (let i = 0; i < passCount; i++) {
						const depthPeelFbo = i % 2 === 0 ? depthPeelFbo1 : depthPeelFbo0;
						const colorFbo = i % 2 === 0 ? colorFbo1 : colorFbo0;
						const depthTarget = i % 2 === 0 ? 0 : 3;
						const frontColorTarget = i % 2 === 0 ? 1 : 4;
						const backColorTarget = i % 2 === 0 ? 5 : 2;

						// Set global state.
						gl.blendEquation(gl.MAX);
						gl.clearColor(0, 0, 0, 0);

						// Bind the framebuffer.
						gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, colorFbo);
						gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);

						// Clear the canvas.
						gl.clear(gl.COLOR_BUFFER_BIT);

						// Set global state.
						gl.clearColor(-(1 + epsilon), -(1 + epsilon), 0, 0);

						// Bind the framebuffer.
						gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, depthPeelFbo);
						gl.drawBuffers([gl.COLOR_ATTACHMENT0]);

						// Clear the canvas.
						gl.clear(gl.COLOR_BUFFER_BIT);

						// Bind the framebuffer.
						gl.drawBuffers([
							gl.COLOR_ATTACHMENT0,
							gl.COLOR_ATTACHMENT1,
							gl.COLOR_ATTACHMENT2
						]);

						// Use the program.
						gl.useProgram(depthPeelProgram);

						// Bind the VAO.
						gl.bindVertexArray(depthPeelPlaneVao);

						// Set uniform values.
						gl.uniform1i(depthPeelDepthTexLoc, depthTarget);
						gl.uniform1i(depthPeelFrontColorTexLoc, frontColorTarget);
						gl.uniform4fv(depthPeelColorLoc, red);
						gl.uniformMatrix4fv(depthPeelWorldMatLoc, false, redMat);

						// Render.
						gl.drawElements(
							gl.TRIANGLES,
							planeIndexData.length,
							gl.UNSIGNED_BYTE,
							0
						);

						// Set uniform values.
						gl.uniform4fv(depthPeelColorLoc, green);
						gl.uniformMatrix4fv(depthPeelWorldMatLoc, false, greenMat);

						// Render
						gl.drawElements(
							gl.TRIANGLES,
							planeIndexData.length,
							gl.UNSIGNED_BYTE,
							0
						);

						// Set global state.
						gl.blendEquation(gl.FUNC_ADD);
						gl.blendFuncSeparate(
							gl.SRC_ALPHA,
							gl.ONE_MINUS_SRC_ALPHA,
							gl.ONE,
							gl.ONE_MINUS_SRC_ALPHA
						);

						// Bind the framebuffer.
						gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, blendBackFbo);
						gl.drawBuffers([gl.COLOR_ATTACHMENT0]);

						// Use the program.
						gl.useProgram(blendBackProgram);

						// Bind the VAO.
						gl.bindVertexArray(blendBackPlaneVao);

						// Set uniform values.
						gl.uniform1i(blendBackBackColorTexLoc, backColorTarget);

						// Render.
						gl.drawElements(
							gl.TRIANGLES,
							planeIndexData.length,
							gl.UNSIGNED_BYTE,
							0
						);
					}

					// Final.

					const frontColorTarget = passCount % 2 === 0 ? 1 : 4;

					// Set global state.
					gl.clearColor(0, 0, 0, 0);
					gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

					// Bind the framebuffer.
					gl.bindFramebuffer(gl.FRAMEBUFFER, null);

					// Clear the canvas.
					gl.clear(gl.COLOR_BUFFER_BIT);

					// Use the program.
					gl.useProgram(finalProgram);

					// Bind the VAO.
					gl.bindVertexArray(finalPlaneVao);

					// Set uniform values.
					gl.uniform1i(finalBackColorTexLoc, 6);
					gl.uniform1i(finalFrontColorTexLoc, frontColorTarget);

					// Render.
					gl.drawElements(
						gl.TRIANGLES,
						planeIndexData.length,
						gl.UNSIGNED_BYTE,
						0
					);
				};
			}

			// μGL implementation.
			function ugl(canvas) {
				const gl = new Context(canvas);

				const depthPeelProgram = Program.fromSource(
					gl,
					depthPeelVss,
					depthPeelFss
				);
				const finalProgram = Program.fromSource(gl, quadVss, finalFss);
				const blendBackProgram = Program.fromSource(gl, quadVss, blendBackFss);

				const planePositionBuffer = new Vbo(gl, planePositionData);
				const planeIndexBuffer = new Ebo(gl, planeIndexData);

				const depthPeelPlaneVao = new Vao(
					depthPeelProgram,
					// eslint-disable-next-line camelcase
					{ a_position: { size: 2, vbo: planePositionBuffer } },
					planeIndexBuffer
				);

				const finalPlaneVao = new Vao(
					finalProgram,
					// eslint-disable-next-line camelcase
					{ a_position: { size: 2, vbo: planePositionBuffer } },
					planeIndexBuffer
				);

				const blendBackPlaneVao = new Vao(
					blendBackProgram,
					// eslint-disable-next-line camelcase
					{ a_position: { size: 2, vbo: planePositionBuffer } },
					planeIndexBuffer
				);

				// Red channel holds the negative front depth, green channel holds the back depth.
				const depthTarget0 = new Texture2d(gl);
				depthTarget0.format = TextureFormat.RG32F;
				depthTarget0.setMip(void 0, 0, void 0, [
					0,
					0,
					gl.drawingBufferWidth,
					gl.drawingBufferHeight
				]);
				depthTarget0.magFilter = TextureFilter.NEAREST;
				depthTarget0.minFilter = TextureFilter.NEAREST;
				depthTarget0.wrapSFunction = WrapMode.CLAMP_TO_EDGE;
				depthTarget0.wrapTFunction = WrapMode.CLAMP_TO_EDGE;

				const frontColorTarget0 = new Texture2d(gl);
				frontColorTarget0.format = TextureFormat.RGBA16F;
				frontColorTarget0.setMip(
					void 0,
					0,
					void 0,
					[0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight],
					TextureDataType.HALF_FLOAT
				);
				frontColorTarget0.magFilter = TextureFilter.NEAREST;
				frontColorTarget0.minFilter = TextureFilter.NEAREST;
				frontColorTarget0.wrapSFunction = WrapMode.CLAMP_TO_EDGE;
				frontColorTarget0.wrapTFunction = WrapMode.CLAMP_TO_EDGE;

				const backColorTarget0 = new Texture2d(gl);
				backColorTarget0.format = TextureFormat.RGBA16F;
				backColorTarget0.setMip(
					void 0,
					0,
					void 0,
					[0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight],
					TextureDataType.HALF_FLOAT
				);
				backColorTarget0.magFilter = TextureFilter.NEAREST;
				backColorTarget0.minFilter = TextureFilter.NEAREST;
				backColorTarget0.wrapSFunction = WrapMode.CLAMP_TO_EDGE;
				backColorTarget0.wrapTFunction = WrapMode.CLAMP_TO_EDGE;

				// Red channel holds the negative front depth, green channel holds the back depth.
				const depthTarget1 = new Texture2d(gl);
				depthTarget1.format = TextureFormat.RG32F;
				depthTarget1.setMip(void 0, 0, void 0, [
					0,
					0,
					gl.drawingBufferWidth,
					gl.drawingBufferHeight
				]);
				depthTarget1.magFilter = TextureFilter.NEAREST;
				depthTarget1.minFilter = TextureFilter.NEAREST;
				depthTarget1.wrapSFunction = WrapMode.CLAMP_TO_EDGE;
				depthTarget1.wrapTFunction = WrapMode.CLAMP_TO_EDGE;

				const frontColorTarget1 = new Texture2d(gl);
				frontColorTarget1.format = TextureFormat.RGBA16F;
				frontColorTarget1.setMip(
					void 0,
					0,
					void 0,
					[0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight],
					TextureDataType.HALF_FLOAT
				);
				frontColorTarget1.magFilter = TextureFilter.NEAREST;
				frontColorTarget1.minFilter = TextureFilter.NEAREST;
				frontColorTarget1.wrapSFunction = WrapMode.CLAMP_TO_EDGE;
				frontColorTarget1.wrapTFunction = WrapMode.CLAMP_TO_EDGE;

				const backColorTarget1 = new Texture2d(gl);
				backColorTarget1.format = TextureFormat.RGBA16F;
				backColorTarget1.setMip(
					void 0,
					0,
					void 0,
					[0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight],
					TextureDataType.HALF_FLOAT
				);
				backColorTarget1.magFilter = TextureFilter.NEAREST;
				backColorTarget1.minFilter = TextureFilter.NEAREST;
				backColorTarget1.wrapSFunction = WrapMode.CLAMP_TO_EDGE;
				backColorTarget1.wrapTFunction = WrapMode.CLAMP_TO_EDGE;

				const blendBackTarget = new Texture2d(gl);
				blendBackTarget.format = TextureFormat.RGBA16F;
				blendBackTarget.setMip(
					void 0,
					0,
					void 0,
					[0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight],
					TextureDataType.HALF_FLOAT
				);
				blendBackTarget.magFilter = TextureFilter.NEAREST;
				blendBackTarget.minFilter = TextureFilter.NEAREST;
				blendBackTarget.wrapSFunction = WrapMode.CLAMP_TO_EDGE;
				blendBackTarget.wrapTFunction = WrapMode.CLAMP_TO_EDGE;

				const depthPeelFbo0 = new Framebuffer(gl);
				depthPeelFbo0.attach(0, depthTarget0);
				depthPeelFbo0.attach(1, frontColorTarget0);
				depthPeelFbo0.attach(2, backColorTarget0);

				const colorFbo0 = new Framebuffer(gl);
				colorFbo0.attach(0, frontColorTarget0);
				colorFbo0.attach(1, backColorTarget0);

				const depthPeelFbo1 = new Framebuffer(gl);
				depthPeelFbo1.attach(0, depthTarget1);
				depthPeelFbo1.attach(1, frontColorTarget1);
				depthPeelFbo1.attach(2, backColorTarget1);

				const colorFbo1 = new Framebuffer(gl);
				colorFbo1.attach(0, frontColorTarget1);
				colorFbo1.attach(1, backColorTarget1);

				const blendBackFbo = new Framebuffer(gl);
				blendBackFbo.attach(0, blendBackTarget);

				const redMat = identity(createMatrix4Like());
				rotateY(redMat, Math.PI / 4, redMat);
				const greenMat = identity(createMatrix4Like());
				rotateY(greenMat, -Math.PI / 4, greenMat);
				const red = fromValues4(1, 0, 0, 0.5, createVector4Like());
				const green = fromValues4(0, 1, 0, 0.5, createVector4Like());
				const projMat = createMatrix4Like();
				const viewMat = createMatrix4Like();
				const eyePos = fromValues(0, 2, 2, createVector3Like());
				lookAt(eyePos, [0, 0, 0], [0, 1, 0], viewMat);
				const viewProjMat = createMatrix4Like();

				return function () {
					if (gl.resize()) {
						depthTarget0.setMip(void 0, 0, void 0, [
							0,
							0,
							gl.drawingBufferWidth,
							gl.drawingBufferHeight
						]);

						frontColorTarget0.setMip(
							void 0,
							0,
							void 0,
							[0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight],
							TextureDataType.HALF_FLOAT
						);

						backColorTarget0.setMip(
							void 0,
							0,
							void 0,
							[0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight],
							TextureDataType.HALF_FLOAT
						);

						depthTarget1.setMip(void 0, 0, void 0, [
							0,
							0,
							gl.drawingBufferWidth,
							gl.drawingBufferHeight
						]);

						frontColorTarget1.setMip(
							void 0,
							0,
							void 0,
							[0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight],
							TextureDataType.HALF_FLOAT
						);

						backColorTarget1.setMip(
							void 0,
							0,
							void 0,
							[0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight],
							TextureDataType.HALF_FLOAT
						);

						blendBackTarget.setMip(
							void 0,
							0,
							void 0,
							[0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight],
							TextureDataType.HALF_FLOAT
						);
					}

					const w = canvas.width;
					const h = canvas.height;
					perspective(Math.PI / 2, w / (h || 1), 1, 5, projMat);
					multiply(projMat, viewMat, viewProjMat);

					gl.doBlend = true;
					gl.blendEquation = BlendEquation.MAX;
					gl.depthMask = false;
					gl.doCullFace = false;

					gl.clear([0, 0, 0, 0], false, false, blendBackFbo);

					colorFbo0.drawBuffers = [0, 1];
					gl.clear([0, 0, 0, 0], false, false, colorFbo0);

					gl.clear([0, 0, 0, 0], false, false, colorFbo1);

					gl.clear([0, 1, 0, 0], false, false, depthPeelFbo1);

					depthPeelFbo0.drawBuffers = [0];
					gl.clear(
						[-(1 + epsilon), -(1 + epsilon), 0, 0],
						false,
						false,
						depthPeelFbo0
					);
					depthPeelPlaneVao.draw(
						{
							// eslint-disable-next-line camelcase
							u_color: red,
							// eslint-disable-next-line camelcase
							u_depthTex: depthTarget1,
							// eslint-disable-next-line camelcase
							u_frontColorTex: frontColorTarget1,
							// eslint-disable-next-line camelcase
							u_viewProjMat: viewProjMat,
							// eslint-disable-next-line camelcase
							u_worldMat: redMat
						},
						void 0,
						void 0,
						depthPeelFbo0
					);
					depthPeelPlaneVao.draw(
						{
							// eslint-disable-next-line camelcase
							u_color: green,
							// eslint-disable-next-line camelcase
							u_depthTex: depthTarget1,
							// eslint-disable-next-line camelcase
							u_frontColorTex: frontColorTarget1,
							// eslint-disable-next-line camelcase
							u_viewProjMat: viewProjMat,
							// eslint-disable-next-line camelcase
							u_worldMat: greenMat
						},
						void 0,
						void 0,
						depthPeelFbo0
					);

					// Dual depth peeling ping-pong.
					const passCount = 1;
					for (let i = 0; i < passCount; i++) {
						const depthPeelFbo = i % 2 === 0 ? depthPeelFbo1 : depthPeelFbo0;
						const colorFbo = i % 2 === 0 ? colorFbo1 : colorFbo0;
						const depthTarget = i % 2 === 0 ? depthTarget0 : depthTarget1;
						const frontColorTarget =
							i % 2 === 0 ? frontColorTarget0 : frontColorTarget1;
						const backColorTarget =
							i % 2 === 0 ? backColorTarget1 : backColorTarget0;

						gl.blendEquation = BlendEquation.MAX;

						colorFbo.drawBuffers = [0, 1];
						gl.clear([0, 0, 0, 0], false, false, colorFbo);

						depthPeelFbo.drawBuffers = [0];
						gl.clear(
							[-(1 + epsilon), -(1 + epsilon), 0, 0],
							false,
							false,
							depthPeelFbo
						);

						depthPeelFbo.drawBuffers = [0, 1, 2];
						depthPeelPlaneVao.draw(
							{
								// eslint-disable-next-line camelcase
								u_color: red,
								// eslint-disable-next-line camelcase
								u_depthTex: depthTarget,
								// eslint-disable-next-line camelcase
								u_frontColorTex: frontColorTarget,
								// eslint-disable-next-line camelcase
								u_viewProjMat: viewProjMat,
								// eslint-disable-next-line camelcase
								u_worldMat: redMat
							},
							void 0,
							void 0,
							depthPeelFbo
						);
						depthPeelPlaneVao.draw(
							{
								// eslint-disable-next-line camelcase
								u_color: green,
								// eslint-disable-next-line camelcase
								u_depthTex: depthTarget,
								// eslint-disable-next-line camelcase
								u_frontColorTex: frontColorTarget,
								// eslint-disable-next-line camelcase
								u_viewProjMat: viewProjMat,
								// eslint-disable-next-line camelcase
								u_worldMat: greenMat
							},
							void 0,
							void 0,
							depthPeelFbo
						);

						gl.blendEquation = BlendEquation.FUNC_ADD;
						gl.blendFunction = [
							BlendFunction.SRC_ALPHA,
							BlendFunction.ONE_MINUS_SRC_ALPHA,
							BlendFunction.ONE,
							BlendFunction.ONE_MINUS_SRC_ALPHA
						];

						blendBackFbo.drawBuffers = [0];
						blendBackPlaneVao.draw(
							// eslint-disable-next-line camelcase
							{ u_backColorTex: backColorTarget },
							void 0,
							void 0,
							blendBackFbo
						);
					}

					// Final.
					const frontColorTarget =
						passCount % 2 === 0 ? frontColorTarget0 : frontColorTarget1;

					gl.blendFunction = [
						BlendFunction.ONE,
						BlendFunction.ONE_MINUS_SRC_ALPHA
					];

					gl.clear([0, 0, 0, 0], false, false);

					finalPlaneVao.draw({
						// eslint-disable-next-line camelcase
						u_backColorTex: blendBackTarget,
						// eslint-disable-next-line camelcase
						u_frontColorTex: frontColorTarget
					});
				};
			}

			// Start after the canvases finish loading.
			addEventListener("load", () => {
				// Set up Spector.js.
				new SPECTOR.Spector().displayUI();

				// Set up both rendering contexts, get separate update functions.
				const rawUpdate = raw(document.querySelector("canvas#raw"));
				const uglUpdate = ugl(document.querySelector("canvas#ugl"));

				// Create a combined update function.
				function update(now) {
					requestAnimationFrame(update);

					// Update both canvases on every frame.
					rawUpdate(now);
					uglUpdate(now);
				}
				requestAnimationFrame(update);
			});
		</script>

		<!-- Canvas visibility style. -->
		<style>
			/* Make canvases more visible. */
			canvas {
				border: 1px solid black;
				width: 512px;
				height: 512px;
			}

			/** Display canvases below the Spector.js UI. */
			div#canvas-wrapper {
				text-align: center;
				padding-top: 120px;
			}
		</style>
	</head>
	<body>
		<div id="canvas-wrapper">
			<canvas id="raw"></canvas>
			<canvas id="ugl"></canvas>
		</div>
	</body>
</html>
